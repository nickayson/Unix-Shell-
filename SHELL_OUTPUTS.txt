input was: 
'cat shell.c &'
osh> // Nicholas Ayson
// Due on March 25, 2021
// Unix Shell project

//===============================================================================================================================================================================

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>


//===============================================================================================================
//Locate pipe char and return inside
//function for the right pipe
int piperhs(char** char_args)
{
    int i = 0;
    while(char_args[i] != '\0')
    {
        if(!strncmp(char_args[i], "|", 1))      //checks to see if | was inputted
        {   
            return i;                               // new char_args starting at offset
        }
        i++;
    }
    return -1;
}// end of locate pipe 
//===============================================================================================================================
//start of parse function
char** parse(char* s, char* char_args[])
{
    const char breakchars[2] = {' ','\t'};
    char* p;
    int num_args = 0;

    p = strtok(s, breakchars);
    char_args[0] = p;

    char** redirectto = malloc(2 * sizeof(char*));

    for(int i = 0; i < 2; i++)
    {
        redirectto[i] = malloc(BUFSIZ * sizeof(char));
    }

    redirectto[0] = "";
    redirectto[1] = "";

    while(p != NULL)
    {
        // add p to char_args
        p = strtok(NULL, breakchars);

        if(p == NULL) 
        {
            break;
        }
        if(!strncmp(p, ">", 1))
        {
            p = strtok(NULL, breakchars);
            redirectto[0] = "o";
            redirectto[1] = p;
            return redirectto;
        } 
        if(!strncmp(p, "<", 1))
        {
            p = strtok(NULL, breakchars);
            redirectto[0] = "i";
            redirectto[1] = p;
            return redirectto;
        }
        if(!strncmp(p, "|", 1))
        {   
            redirectto[0] = "p";        
        }
        char_args[num_args+1] = p;
    }
    return redirectto;
}   // end of parse function
//=========================================================================================
int main(int argc, const char* argv[])
{
    char input [BUFSIZ];            //given
    char last_command [BUFSIZ]; 
    int pipefd[2];              // pipe file

    // clear buffers
    memset(input, 0, BUFSIZ * sizeof(char));
    memset(last_command,   0, BUFSIZ * sizeof(char));   //given
    bool finished = false; //=0 also given

    while(!finished)
    {
        printf("osh> ");            //given
        fflush(stdout); 

        bool waitone = true;
        // read into input
        if (fgets(input, BUFSIZ, stdin)==NULL)
        {
            fprintf(stderr,"no command entered\n");
            exit(1);
        }

        input[strlen(input) - 1] = '\0';                // replace newline with null
        printf("input was: \n'%s'\n", input);

        if(strncmp(input, "!!", 2))                 // history
        {
            strcpy(last_command, input);
        } 
        if(strncmp(input, "exit", 4) == 0)          //get out of osh
        {
            return 0;
        }
        char* offset = strstr(input, "&");
        if(offset != NULL)
        {
            *offset = ' '; 
            waitone = false;
        } 
        //fork function to create child begins here
        pid_t pid = fork();
        int valuechild = 0;
        if(pid < valuechild)
        {
            fprintf(stderr, "fork failed...\n");
            exit(1); // exit
        }
        else if(pid != valuechild)      //parent
        {   
            if(waitone)
            {
                wait(NULL);         // wait if used with '&'
                wait(NULL);
            }
        }  
        else    //child
        {
            int history = 0;
            char* char_args[BUFSIZ];
            memset(char_args, 0, BUFSIZ * sizeof(char));

            // if we use '!!' we want to read from last_command for child now
            if(!strncmp(input, "!!", 2))
            {
                history = 1;
            }
            char** redirect = parse( (history ? last_command : input), char_args); // redirects to the instructions in parse
            // no command entered before history 
            if(history && last_command[0] == '\0')
            {
                printf("No command used.\n");
                exit(1);
            } 
            if(!strncmp(redirect[0], "o", 1))       // output redirect for the output
            {
                printf("Output saved to the file./%s\n", redirect[1]);
                int file = open(redirect[1], O_TRUNC | O_CREAT | O_RDWR);
                dup2(file, STDOUT_FILENO);        // redirect stdout to file 
            }
            if(!strncmp(redirect[0], "i", 1))      //redirect for the read
            { 
                printf("Reading from file: ./%s\n", redirect[1]);
                int file = open(redirect[1], O_RDONLY);   
                memset(input, 0, BUFSIZ * sizeof(char));
                memset(char_args, 0, BUFSIZ * sizeof(char));    //buffer reset
                read(file, input,  BUFSIZ * sizeof(char));
                input[strlen(input) - 1]  = '\0';
                parse(input, char_args);
            }
                execvp(char_args[0], char_args);                                //The things args array will be passed to
                exit(0);
        }  
    }
    printf("osh exited\n");
    printf("program finished\n");
    return 0;    
} 
//end of main
//===================================================================================================================
input was: 
''
osh> exit
input was: 
'exit'
osc@ubuntu:~/final-src-osc10e/ch3$ ./shell
osh> cat shell.c &
input was: 
'cat shell.c &'
osh> // Nicholas Ayson
// Due on March 25, 2021
// Unix Shell project

//===============================================================================================================================================================================


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>


//===============================================================================================================
//Locate pipe char and return inside
//function for the right pipe
int piperhs(char** char_args)
{
    int i = 0;
    while(char_args[i] != '\0')
    {
        if(!strncmp(char_args[i], "|", 1))      //checks to see if | was inputted
        {   
            return i;                               // new char_args starting at offset
        }
        i++;
    }
    return -1;
}// end of locate pipe 
//===============================================================================================================================
//start of parse function
char** parse(char* s, char* char_args[])
{
    const char breakchars[2] = {' ','\t'};
    char* p;
    int num_args = 0;

    p = strtok(s, breakchars);
    char_args[0] = p;

    char** redirectto = malloc(2 * sizeof(char*));

    for(int i = 0; i < 2; i++)
    {
        redirectto[i] = malloc(BUFSIZ * sizeof(char));
    }

    redirectto[0] = "";
    redirectto[1] = "";

    while(p != NULL)
    {
        // add p to char_args
        p = strtok(NULL, breakchars);

        if(p == NULL) 
        {
            break;
        }
        if(!strncmp(p, ">", 1))
        {
            p = strtok(NULL, breakchars);
            redirectto[0] = "o";
            redirectto[1] = p;
            return redirectto;
        } 
        if(!strncmp(p, "<", 1))
        {
            p = strtok(NULL, breakchars);
            redirectto[0] = "i";
            redirectto[1] = p;
            return redirectto;
        }
        if(!strncmp(p, "|", 1))
        {   
            redirectto[0] = "p";        
        }
        char_args[num_args+1] = p;
    }
    return redirectto;
}   // end of parse function
//=========================================================================================
int main(int argc, const char* argv[])
{
    char input [BUFSIZ];            //given
    char last_command [BUFSIZ]; 
    int pipefd[2];              // pipe file

    // clear buffers
    memset(input, 0, BUFSIZ * sizeof(char));
    memset(last_command,   0, BUFSIZ * sizeof(char));   //given
    bool finished = false; //=0 also given

    while(!finished)
    {
        printf("osh> ");            //given
        fflush(stdout); 

        bool waitone = true;
        // read into input
        if (fgets(input, BUFSIZ, stdin)==NULL)
        {
            fprintf(stderr,"no command entered\n");
            exit(1);
        }

        input[strlen(input) - 1] = '\0';                // replace newline with null
        printf("input was: \n'%s'\n", input);

        if(strncmp(input, "!!", 2))                 // history
        {
            strcpy(last_command, input);
        } 
        if(strncmp(input, "exit", 4) == 0)          //get out of osh
        {
            return 0;
        }
        char* offset = strstr(input, "&");
        if(offset != NULL)
        {
            *offset = ' '; 
            waitone = false;
        } 
        //fork function to create child begins here
        pid_t pid = fork();
        int valuechild = 0;
        if(pid < valuechild)
        {
            fprintf(stderr, "fork failed...\n");
            exit(1); // exit
        }
        else if(pid != valuechild)      //parent
        {   
            if(waitone)
            {
                wait(NULL);         // wait if used with '&'
                wait(NULL);
            }
        }  
        else    //child
        {
            int history = 0;
            char* char_args[BUFSIZ];
            memset(char_args, 0, BUFSIZ * sizeof(char));

            // if we use '!!' we want to read from last_command for child now
            if(!strncmp(input, "!!", 2))
            {
                history = 1;
            }
            char** redirect = parse( (history ? last_command : input), char_args); // redirects to the instructions in parse
            // no command entered before history 
            if(history && last_command[0] == '\0')
            {
                printf("No command used.\n");
                exit(1);
            } 
            if(!strncmp(redirect[0], "o", 1))       // output redirect for the output
            {
                printf("Output saved to the file./%s\n", redirect[1]);
                int file = open(redirect[1], O_TRUNC | O_CREAT | O_RDWR);
                dup2(file, STDOUT_FILENO);        // redirect stdout to file 
            }
            if(!strncmp(redirect[0], "i", 1))      //redirect for the read
            { 
                printf("Reading from file: ./%s\n", redirect[1]);
                int file = open(redirect[1], O_RDONLY);   
                memset(input, 0, BUFSIZ * sizeof(char));
                memset(char_args, 0, BUFSIZ * sizeof(char));    //buffer reset
                read(file, input,  BUFSIZ * sizeof(char));
                input[strlen(input) - 1]  = '\0';
                parse(input, char_args);
            }
                execvp(char_args[0], char_args);                                //The things args array will be passed to
                exit(0);
        }  
    }
    printf("osh exited\n");
    printf("program finished\n");
    return 0;    
} 
//end of main
//===================================================================================================================
input was: 
''
osh> 

//=============================================================================================================================================================================================================

osh> ls
DateClient.java  fig3-30.c  fig3-32.c  fig3-33.c  fig3-35.c       multi-fork    newproc-posix.c  output_file      pid.c  shell.c            shm-posix-consumer.c  simple-shell    unix_pipe.c         win32-pipe-parent.c
DateServer.java  fig3-31.c  fig3-33    fig3-34.c  input_file.txt  multi-fork.c  newproc-win32.c  output_file.txt  shell  SHELL_OUTPUTS.txt  shm-posix-producer.c  simple-shell.c  win32-pipe-child.c
osh> 


//=============================================================================================================================================================================================================
osh> exit
osc@ubuntu:~/final-src-osc10e/ch3$ 
//===============================================================================================================================================================================================================

osh> ls -l
total 152
-rw-rw-r-- 1 osc osc   710 Jan  3  2018 DateClient.java
-rw-rw-r-- 1 osc osc   810 Jun 18  2018 DateServer.java
-rw-rw-r-- 1 osc osc   361 Jun 18  2018 fig3-30.c
-rw-rw-r-- 1 osc osc   121 Jan  3  2018 fig3-31.c
-rw-rw-r-- 1 osc osc   136 Jan  3  2018 fig3-32.c
-rwxrwxr-x 1 osc osc 10288 Mar 15 16:11 fig3-33
-rw-rw-r-- 1 osc osc   509 Mar 15 16:11 fig3-33.c
-rw-rw-r-- 1 osc osc   680 Jun 18  2018 fig3-34.c
-rw-rw-r-- 1 osc osc   534 Jun 18  2018 fig3-35.c
-rw-rw-r-- 1 osc osc     2 Mar 15 17:47 input_file.txt
-rwxrwxr-x 1 osc osc  8712 Jan 30  2018 multi-fork
-rw-rw-r-- 1 osc osc   257 Jan 30  2018 multi-fork.c
-rw-rw-r-- 1 osc osc   780 Jan 28  2018 newproc-posix.c
-rw-rw-r-- 1 osc osc  1413 Jan  3  2018 newproc-win32.c
-rw---S--T 1 osc osc     0 Mar 15 16:45 output_file
-rw---S--T 1 osc osc   340 Mar 15 17:51 output_file.txt
-rw-r--r-- 1 osc osc  2976 Jun 18  2018 pid.c
-rwxrwxr-x 1 osc osc 17312 Mar 15 18:41 shell
-rw-rw-r-- 1 osc osc  6525 Mar 15 18:42 shell.c
-rw-rw-r-- 1 osc osc  6549 Mar 15 18:46 SHELL_OUTPUTS.txt
-rw-rw-r-- 1 osc osc  1115 Jun 18  2018 shm-posix-consumer.c
-rw-rw-r-- 1 osc osc  1434 Jun 18  2018 shm-posix-producer.c
-rwxrwxr-x 1 osc osc 10112 Mar 15 16:15 simple-shell
-rw-rw-r-- 1 osc osc   707 Jun 18  2018 simple-shell.c
-rw-rw-r-- 1 osc osc  1219 Jan  3  2018 unix_pipe.c
-rw-rw-r-- 1 osc osc   755 Jan  3  2018 win32-pipe-child.c
-rw-rw-r-- 1 osc osc  2236 Jan  3  2018 win32-pipe-parent.c

===================================================================================================================================================================================================================

osh> !!
total 156
-rw-rw-r-- 1 osc osc   710 Jan  3  2018 DateClient.java
-rw-rw-r-- 1 osc osc   810 Jun 18  2018 DateServer.java
-rw-rw-r-- 1 osc osc   361 Jun 18  2018 fig3-30.c
-rw-rw-r-- 1 osc osc   121 Jan  3  2018 fig3-31.c
-rw-rw-r-- 1 osc osc   136 Jan  3  2018 fig3-32.c
-rwxrwxr-x 1 osc osc 10288 Mar 15 16:11 fig3-33
-rw-rw-r-- 1 osc osc   509 Mar 15 16:11 fig3-33.c
-rw-rw-r-- 1 osc osc   680 Jun 18  2018 fig3-34.c
-rw-rw-r-- 1 osc osc   534 Jun 18  2018 fig3-35.c
-rw-rw-r-- 1 osc osc     2 Mar 15 17:47 input_file.txt
-rwxrwxr-x 1 osc osc  8712 Jan 30  2018 multi-fork
-rw-rw-r-- 1 osc osc   257 Jan 30  2018 multi-fork.c
-rw-rw-r-- 1 osc osc   780 Jan 28  2018 newproc-posix.c
-rw-rw-r-- 1 osc osc  1413 Jan  3  2018 newproc-win32.c
-rw---S--T 1 osc osc     0 Mar 15 16:45 output_file
-rw---S--T 1 osc osc   340 Mar 15 17:51 output_file.txt
-rw-r--r-- 1 osc osc  2976 Jun 18  2018 pid.c
-rwxrwxr-x 1 osc osc 17312 Mar 15 18:41 shell
-rw-rw-r-- 1 osc osc  6525 Mar 15 18:42 shell.c
-rw-rw-r-- 1 osc osc  9114 Mar 15 18:48 SHELL_OUTPUTS.txt
-rw-rw-r-- 1 osc osc  1115 Jun 18  2018 shm-posix-consumer.c
-rw-rw-r-- 1 osc osc  1434 Jun 18  2018 shm-posix-producer.c
-rwxrwxr-x 1 osc osc 10112 Mar 15 16:15 simple-shell
-rw-rw-r-- 1 osc osc   707 Jun 18  2018 simple-shell.c
-rw-rw-r-- 1 osc osc  1219 Jan  3  2018 unix_pipe.c
-rw-rw-r-- 1 osc osc   755 Jan  3  2018 win32-pipe-child.c
-rw-rw-r-- 1 osc osc  2236 Jan  3  2018 win32-pipe-parent.c
osh> 

=============================================================================================================================================================================================================================

osh> ls > output_file
Output saved to the file./output_file
osh> 
DateClient.java
DateServer.java
fig3-30.c
fig3-31.c
fig3-32.c
fig3-33
fig3-33.c
fig3-34.c
fig3-35.c
input_file.txt
multi-fork
multi-fork.c
newproc-posix.c
newproc-win32.c
output_file
output_file.txt
pid.c
shell
shell.c
SHELL_OUTPUTS.txt
shm-posix-consumer.c
shm-posix-producer.c
simple-shell
simple-shell.c
unix_pipe.c
win32-pipe-child.c
win32-pipe-parent.c

=========================================================================================================================================================================================

=====================================================================================================================================================================================

osh> < input_file.txt > output_file.txt
Output saved to the file./output_file.txt

================================================================================================================================================================================

osh> ls < input_file.txt 
Reading from file: ./input_file.txt
total 160
-rw-rw-r-- 1 osc osc   710 Jan  3  2018 DateClient.java
-rw-rw-r-- 1 osc osc   810 Jun 18  2018 DateServer.java
-rw-rw-r-- 1 osc osc   361 Jun 18  2018 fig3-30.c
-rw-rw-r-- 1 osc osc   121 Jan  3  2018 fig3-31.c
-rw-rw-r-- 1 osc osc   136 Jan  3  2018 fig3-32.c
-rwxrwxr-x 1 osc osc 10288 Mar 15 16:11 fig3-33
-rw-rw-r-- 1 osc osc   509 Mar 15 16:11 fig3-33.c
-rw-rw-r-- 1 osc osc   680 Jun 18  2018 fig3-34.c
-rw-rw-r-- 1 osc osc   534 Jun 18  2018 fig3-35.c
-rw-rw-r-- 1 osc osc     6 Mar 15 19:10 input_file.txt
-rwxrwxr-x 1 osc osc  8712 Jan 30  2018 multi-fork
-rw-rw-r-- 1 osc osc   257 Jan 30  2018 multi-fork.c
-rw-rw-r-- 1 osc osc   780 Jan 28  2018 newproc-posix.c
-rw-rw-r-- 1 osc osc  1413 Jan  3  2018 newproc-win32.c
-rw---S--T 1 osc osc     0 Mar 15 18:52 output_file
-rw---S--T 1 osc osc     0 Mar 15 19:07 output_file.txt
-rw---S--T 1 osc osc    11 Mar 15 19:02 out.txt
-rw-r--r-- 1 osc osc  2976 Jun 18  2018 pid.c
-rwxrwxr-x 1 osc osc 17312 Mar 15 18:41 shell
-rw-rw-r-- 1 osc osc  6510 Mar 15 19:05 shell.c
-rw-rw-r-- 1 osc osc 12814 Mar 15 19:10 SHELL_OUTPUTS.txt
-rw-rw-r-- 1 osc osc  1115 Jun 18  2018 shm-posix-consumer.c
-rw-rw-r-- 1 osc osc  1434 Jun 18  2018 shm-posix-producer.c
-rwxrwxr-x 1 osc osc 10112 Mar 15 16:15 simple-shell
-rw-rw-r-- 1 osc osc   707 Jun 18  2018 simple-shell.c
-rw-rw-r-- 1 osc osc  1219 Jan  3  2018 unix_pipe.c
-rw-rw-r-- 1 osc osc   755 Jan  3  2018 win32-pipe-child.c
-rw-rw-r-- 1 osc osc  2236 Jan  3  2018 win32-pipe-parent.c
osh> 

======================================================================================================================================================================================
cannot get ls -l | less not recognized